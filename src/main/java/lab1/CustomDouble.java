package lab1;

import java.util.Objects;

public class CustomDouble implements Comparable {
    private int intPart;
    private double doublePart;

    public int getIntPart() {
        return intPart;
    }

    public void setIntPart(final int intPart) {
        this.intPart = intPart;
    }

    public double getDoublePart() {
        return doublePart;
    }

    public void setDoublePart(final double doublePart) {
        this.doublePart = doublePart;
    }

    public CustomDouble() {

    }

    public CustomDouble(final int intPart, final double doublePart) {
        this.intPart = intPart;
        this.doublePart = doublePart;
    }

    public CustomDouble sum(final Object o) {
        final CustomDouble res = new CustomDouble();
        final CustomDouble that = (CustomDouble)o;

        res.setIntPart(this.getIntPart() + that.getIntPart());
        res.setDoublePart(this.getDoublePart() + that.getDoublePart());
//        final double temp = this.toDouble() + that.toDouble();
//        res.setIntPart((int) temp);
//        res.setDoublePart(temp % 1);

        return res;
    }

    public CustomDouble diff(final Object o) {
        final CustomDouble res = new CustomDouble();
        final CustomDouble that = (CustomDouble)o;

        res.setIntPart(this.getIntPart() - that.getIntPart());
        res.setDoublePart(this.getDoublePart() - that.getDoublePart());
//        final double temp = this.toDouble() - that.toDouble();
//        res.setIntPart((int) temp);
//        res.setDoublePart(temp % 1);

        return res;
    }

    public CustomDouble mul(final Object o) {
        final CustomDouble res = new CustomDouble();
        final CustomDouble that = (CustomDouble)o;

        final double temp = this.toDouble() * that.toDouble();
        res.setIntPart((int) temp);
        res.setDoublePart(temp % 1);

        return res;
    }

    public CustomDouble div(final Object o) {
        final CustomDouble res = new CustomDouble();
        final CustomDouble that = (CustomDouble)o;

        final double temp = this.toDouble() / that.toDouble();
        res.setIntPart((int) temp);
        res.setDoublePart(temp % 1);

        return res;
    }

    @Override
    public int compareTo(final Object o){
        final CustomDouble that = (CustomDouble)o;
        if (this.toDouble() > that.toDouble()) {
            return 1;
        }
        if (this.toDouble() < that.toDouble()) {
            return -1;
        }
        return 0;
    }

    @Override
    public boolean equals(final Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final CustomDouble that = (CustomDouble) o;
        //Solution 1 (autogenerated)
        return intPart == that.intPart && Double.compare(that.doublePart, doublePart) == 0;

        //Solution 2
        //return this.hashCode() == that.hashCode();
    }

    @Override
    public int hashCode() {
        //Solution 1 (autogenerated)
        return Objects.hash(intPart, doublePart);

        //Solution 2
        //Следуйте следующим общепринятым правилам при переопределении метода hashCode():
        //1. Присвойте результирующей переменной (result) некоторое ненулевое простое число (например, 17)
        //2. Если поле value имеет тип boolean, вычислите (value ? О : 1)
        //3. Если поле value имеет тип byte, char, short или int, вычислите (int)value
        //4. Если поле value имеет тип long, вычислите (int)(value - (value >>> 32))
        //5. Если поле value имеет тип float, вычислите Float.floatToIntBits(value)
        //6. Если поле value имеет тип double, вычислите Double.doubleToLongBits(value), а затем преобразуйте полученное значение, как указано в п.4
        //7. Если поле value является ссылкой на объект, вызывайте метод hashCode() этого объекта
        //8. Если поле value является ссылкой на объект и равно null, используйте число 0 для представления его хэш-кода
        //9. Объедините полученные в п. 2 - п. 8 значения следующим образом: 37*result + value
        //10. Если поле является массивом, примените правило 9 для каждого элемента массива
        //11. Проверьте, что равные объекты возвращают одинаковый hashCode
        //int hash = 3;
        //hash = 53 * hash + this.intPart;
        //hash = 53 * hash + (int) (Double.doubleToLongBits(this.doublePart) ^ (Double.doubleToLongBits(this.doublePart) >>> 32));
        //return hash;
    }

    public double toDouble() {
        //return Double.valueOf(String.valueOf(intPart)+"."+String.valueOf(doublePart));
        return (getIntPart() + getDoublePart());
    }
}

